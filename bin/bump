#!/usr/bin/env ruby
# frozen_string_literal: true

require "bundler/setup"
require "bump"
require_relative "../lib/observable/version"

def usage
  puts <<~USAGE
    Usage: bin/bump [--major|--minor|--patch|--alpha|--beta]
    
    Bumps the version in lib/observable/version.rb and updates CHANGELOG.md
    
    Options:
      --patch (default): Increment patch version (0.1.1 -> 0.1.2)
      --minor:           Increment minor version (0.1.1 -> 0.2.0)
      --major:           Increment major version (0.1.1 -> 1.0.0)
      --alpha:           Increment alpha pre-release (0.1.1 -> 0.1.2-alpha.1)
      --beta:            Increment beta pre-release (0.1.1 -> 0.1.2-beta.1)
    
    Examples:
      bin/bump           # Bump patch version
      bin/bump --patch   # Bump patch version
      bin/bump --minor   # Bump minor version
      bin/bump --major   # Bump major version
      bin/bump --alpha   # Bump alpha pre-release
      bin/bump --beta    # Bump beta pre-release
  USAGE
end

def bump_version_with_gem(bump_type)
  # Use the bump gem to handle version bumping
  result = case bump_type
  when :major
    Bump::Bump.run("major", commit: true, tag: false, bundle: true)
  when :minor
    Bump::Bump.run("minor", commit: true, tag: false, bundle: true)
  when :patch
    Bump::Bump.run("patch", commit: true, tag: false, bundle: true)
  when :alpha
    # For alpha, we need to create a pre-release version
    current_version = Observable::VERSION
    alpha_version = create_pre_release_version(current_version, "alpha")
    system("bundle exec bump set #{alpha_version} --no-commit --no-bundle")
    alpha_version
  when :beta
    # For beta, we need to create a pre-release version
    current_version = Observable::VERSION
    beta_version = create_pre_release_version(current_version, "beta")
    system("bundle exec bump set #{beta_version} --no-commit --no-bundle")
    beta_version
  else
    raise "Invalid bump type: #{bump_type}"
  end
  
  # The bump gem returns an array with [version, exit_code], we want just the version
  # For alpha and beta, we return the version directly
  if bump_type == :alpha || bump_type == :beta
    result
  else
    result.is_a?(Array) ? result[0] : result
  end
end

def create_pre_release_version(current_version, pre_type)
  # Parse current version and create pre-release version
  # Handle versions like: 1.0.0, 1.0.0-alpha.1, 1.0.0-alpha.1.1.1
  match = current_version.match(/(\d+)\.(\d+)\.(\d+)(?:-(.+))?/)
  return nil unless match

  major, minor, patch, pre_suffix = match[1..4]
  
  if pre_suffix && pre_suffix.start_with?("#{pre_type}.")
    # Increment existing pre-release number
    # Extract the number part after the pre_type
    number_part = pre_suffix.sub("#{pre_type}.", "")
    # Split by dots and increment the last number
    parts = number_part.split(".")
    last_number = parts.last.to_i + 1
    parts[-1] = last_number.to_s
    "#{major}.#{minor}.#{patch}-#{pre_type}.#{parts.join('.')}"
  else
    # Create new pre-release version
    "#{major}.#{minor}.#{patch}-#{pre_type}.1"
  end
end

def update_changelog(new_version)
  changelog_file = "CHANGELOG.md"
  return unless File.exist?(changelog_file)
  
  content = File.read(changelog_file)
  today = Time.now.strftime("%Y-%m-%d")
  
  # Get commits since last tag and categorize them
  recent_commits = get_recent_commits_since_last_tag
  categorized_commits = categorize_commits(recent_commits)
  
  # Generate changelog content from commits
  changelog_content = generate_changelog_content(categorized_commits)
  
  # If no commits found or no content generated, use default
  if changelog_content.empty?
    changelog_content = "### Changed\n- Version bump\n\n"
  end
  
  new_entry = <<~ENTRY
    ## [#{new_version}] - #{today}

    #{changelog_content}
  ENTRY
  
  # Insert new version entry after "## [Unreleased]"
  updated_content = content.sub(/(## \[Unreleased\]\s*\n)/, "\\1\n#{new_entry}")
  
  File.write(changelog_file, updated_content)
  puts "Updated #{changelog_file} with new version entry"
  
  if recent_commits.any?
    puts "📝 Generated changelog from #{recent_commits.length} commit(s) since last tag"
  end
end

def get_recent_commits_since_last_tag
  # Get the last tag
  last_tag = `git describe --tags --abbrev=0 2>/dev/null`.strip
  return [] if last_tag.empty?
  
  # Get commits since last tag with full commit messages
  commits = `git log #{last_tag}..HEAD --no-merges --pretty=format:"%s"`.strip.split("\n")
  commits.map(&:strip).reject(&:empty?)
end

def parse_conventional_commit(commit_message)
  # Parse conventional commit format: type(scope): description
  # Examples: feat: add new feature, fix(auth): resolve login issue, chore: update dependencies
  match = commit_message.match(/^(\w+)(?:\(([^)]+)\))?: (.+)$/)
  
  if match
    type = match[1].downcase
    scope = match[2]
    description = match[3]
    
    # Map conventional commit types to changelog sections
    section = case type
    when 'feat', 'feature'
      'Added'
    when 'fix', 'bugfix'
      'Fixed'
    when 'perf'
      'Performance'
    when 'refactor'
      'Changed'
    when 'style'
      'Changed'
    when 'test'
      'Changed'
    when 'chore'
      'Changed'
    when 'docs'
      'Changed'
    when 'ci'
      'Changed'
    when 'build'
      'Changed'
    when 'revert'
      'Changed'
    else
      'Changed'
    end
    
    {
      type: type,
      scope: scope,
      description: description,
      section: section,
      formatted: scope ? "#{description} (#{scope})" : description
    }
  else
    # Non-conventional commit, treat as general change
    {
      type: 'other',
      scope: nil,
      description: commit_message,
      section: 'Changed',
      formatted: commit_message
    }
  end
end

def categorize_commits(commits)
  categorized = Hash.new { |h, k| h[k] = [] }
  
  commits.each do |commit|
    parsed = parse_conventional_commit(commit)
    categorized[parsed[:section]] << parsed[:formatted]
  end
  
  categorized
end

def generate_changelog_content(categorized_commits)
  return "" if categorized_commits.empty?
  
  content = ""
  
  # Define section order
  section_order = ['Added', 'Fixed', 'Performance', 'Changed']
  
  section_order.each do |section|
    if categorized_commits[section]&.any?
      content += "### #{section}\n"
      categorized_commits[section].each do |item|
        content += "- #{item}\n"
      end
      content += "\n"
    end
  end
  
  # Add any remaining sections not in the predefined order
  categorized_commits.each do |section, items|
    unless section_order.include?(section)
      content += "### #{section}\n"
      items.each do |item|
        content += "- #{item}\n"
      end
      content += "\n"
    end
  end
  
  content
end

def suggest_changelog_updates(new_version)
  recent_commits = get_recent_commits_since_last_tag
  
  if recent_commits.any?
    puts "\n📝 Recent commits since last tag:"
    recent_commits.each { |commit| puts "  - #{commit}" }
    puts "\n💡 Consider updating CHANGELOG.md with meaningful changes before committing."
  end
end

# Parse command line arguments
bump_type = :patch

case ARGV[0]
when "--help", "-h"
  usage
  exit 0
when "--major"
  bump_type = :major
when "--minor"
  bump_type = :minor
when "--patch", nil
  bump_type = :patch
when "--alpha"
  bump_type = :alpha
when "--beta"
  bump_type = :beta
else
  puts "Error: Unknown option '#{ARGV[0]}'"
  puts
  usage
  exit 1
end

# Get current version
current_version = Observable::VERSION
puts "Current version: #{current_version}"

# Calculate new version using bump gem
begin
  new_version = bump_version_with_gem(bump_type)
  puts "New version: #{new_version} (#{bump_type} bump)"
rescue => e
  puts "Error: Failed to bump version - #{e.message}"
  exit 1
end

# Confirm the change
print "Proceed with version bump? [y/N]: "
response = STDIN.gets.strip.downcase

unless response == 'y' || response == 'yes'
  puts "Version bump cancelled."
  exit 0
end

# Update changelog
update_changelog(new_version)

# Suggest changelog review
suggest_changelog_updates(new_version)

puts "\n✅ Version bumped successfully!"
puts "Next steps:"
puts "  1. Review the auto-generated CHANGELOG.md entries"
puts "  2. Commit the changes: git add -A && git commit -m 'chore: bump version to #{new_version}'"
puts "  3. Push to trigger release: git push origin main"